# -*- coding: utf-8 -*-
"""HW1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qBpUld4mmUzftL484J4G85ifbl4_Rk2g
"""

#!/usr/bin/python
__author__ = "Samuel Yu"
__email__ = "samuel.yu@yale.edu"
__copyright__ = "Copyright 2023"
__license__ = "GPL"
__version__ = "1.0.0"

### Usage: python hw1.py -i <input file> -s <score file>
### Example: python hw1.py -i input.txt -s blosum62.txt
### Note: Smith-Waterman Algorithm

import argparse

### This is one way to read in arguments in Python. 
parser = argparse.ArgumentParser(description='Smith-Waterman Algorithm')
parser.add_argument('-i', '--input', help='input file', required=True)
parser.add_argument('-s', '--score', help='score file', required=True)
parser.add_argument('-o', '--opengap', help='open gap', required=False, default=-2)
parser.add_argument('-e', '--extgap', help='extension gap', required=False, default=-1)
args = parser.parse_args()

### Implement your Smith-Waterman Algorithm
def runSW(inputFile, scoreFile, openGap, extGap):
    ### calculation
    # import peptide strings and record their lengths
    with open(inputFile, 'r') as f:
      seqs = [line.strip() for line in f] # each line as a list entry
      # first the column number, then the row number
      col_row = [len(seqs[0]),len(seqs[1])]

    # build a Blosum dictionary
    i = 0 # this will decide where the score lines start
    s = {'A':{},'B':{},'C':{},'D':{},'E':{},
           'F':{},'G':{},'H':{},'I':{},'K':{},
           'L':{},'M':{},'N':{},'P':{},'Q':{},
           'R':{},'S':{},'T':{},'V':{},'W':{},
           'X':{},'Y':{},'Z':{}} # similarity scores dictionary
    
    with open(scoreFile, 'r') as f:
      for line in f:
        if i == 0: # first line is that of alphabets
          keys = list(s.keys())
          i += 1
        else: # all other lines contain the scores
          lst = line.strip().split(' ')
          # lst.remove('\n')
          while '' in lst: lst.remove('')
          if len(lst) > 0:
            for j in range(23):
              s[lst[0]][keys[j]] = int(lst[j+1])

    # initialize the score matrix & tracing matrix
    score_matrix,trace_matrix = [],[]
    m,n = col_row[1],col_row[0] # row & column number

    # initialize to (m+1)*(n+1)
    for i in range(m+1):
        score_matrix.append([0 for j in range(n+1)])
        trace_matrix.append(["" for j in range(n+1)])
    # fill in with similarity scores for each pair of letters
    for i in range(1,m+1):
        for j in range(1,n+1):
            score_matrix[i][j] = s[seqs[1][i-1]][seqs[0][j-1]]

    # initialize alignment score
    a_score = 0 # maximum alignment score
    i_a_score,j_a_score = 0,0 # matrix position of a_score

    # update matrix
    for i in range(1,m+1): # each row
      for j in range(1,n+1): # each column
        # case 1: similarity score at (i,j) + alignment score at (i-1,j-1)
        score_matrix[i][j] += score_matrix[i-1][j-1]
        trace_matrix[i][j] = "UL" # traces from upper left

        # case 2: alignment score along sequence 1 at (k,j) (0<=k<i) + gap penalty
        for k in range(i-1,-1,-1):
            if score_matrix[k][j] + openGap + extGap*(i-k-1) > score_matrix[i][j]:
                score_matrix[i][j] = score_matrix[k][j] + openGap + extGap*(i-k-1)
                trace_matrix[i][j] = "U" # traces from up

        # case 3: alignment score along sequence 2 at (i,k) (0<=k<j) + gap penalty
        for k in range(j-1,-1,-1):
            if score_matrix[i][k] + openGap + extGap*(j-k-1) > score_matrix[i][j]:
                score_matrix[i][j] = score_matrix[i][k] + openGap + extGap*(j-k-1)
                trace_matrix[i][j] = "L" # traces from left

        # case 4: 0
        if 0 > score_matrix[i][j]:
            score_matrix[i][j] = 0
            trace_matrix[i][j] = ""

        # update maximum alignment score & its position
        if score_matrix[i][j] >= a_score:
          a_score = score_matrix[i][j]
          i_a_score,j_a_score = i,j
    
    ### write output
    align0,align1,matches = "","","" # alignment of 1st and 2nd sequence,
                                     # and the matching lines, respectively

    # first write the rightmost unmatched portions
    for j in range(n-1,j_a_score-1,-1): # sequence 1
        align0 = seqs[0][j] + align0
        align1 = " " + align1
        matches = " " + matches
    for i in range(m-1,i_a_score-1,-1): # sequence 2
        align0 = " " + align0
        align1 = seqs[1][i] + align1
        matches = " " + matches

    # rightmost end of alignment matching
    align0 = ")" + align0
    align1 = ")" + align1
    matches = " " + matches

    # core portion of Smith-Waterman local alignment algorithm
    i,j = i_a_score,j_a_score # initialize
    while True:
      # the entry does not trace back anywhere, marks end of tracing
      if trace_matrix[i][j] == "": break

      # trace upper left
      elif trace_matrix[i][j] == "UL":
        # add letters to both alignments
        align0 = seqs[0][j-1] + align0
        align1 = seqs[1][i-1] + align1
        
        if seqs[0][j-1] == seqs[1][i-1]:
            matches = "|" + matches # letters match
        else:
            matches = " " + matches # letters don't match
        # update upper left
        i -= 1
        j -= 1

      # trace left
      elif trace_matrix[i][j] == "L":
        # add letter to 1st alignment, blank to the other
        align0 = seqs[0][j-1] + align0
        align1 = "-" + align1
        matches = " " + matches
        
        # update left
        j -= 1

      # trace up
      elif trace_matrix[i][j] == "U":
        # add letter to 1st alignment, blank to the other
        align0 = "-" + align0
        align1 = seqs[1][i-1] + align1
        matches = " " + matches
        
        # update up
        i -= 1
      
    # leftmost end of alignment matching
    align0 = "(" + align0
    align1 = "(" + align1
    matches = " " + matches

    # last write the leftmost unmatched portions
    while i > 0 or j > 0:
      if j > 0: # 1st sequence not yet complete
        align0 = seqs[0][j-1] + align0
        j -= 1
      else: # complete
        align0 = " " + align0
      
      if i > 0: # 2nd sequence not yet complete
        align1 = seqs[1][i-1] + align1
        i -= 1
      else: # complete
        align1 = " " + align1
      matches = " " + matches

    print("-----------\n")
    print("|Sequences|\n")
    print("-----------\n")
    
    print("sequence1\n")
    print(seqs[0] + "\n")
    print("sequence2\n")
    print(seqs[1] + "\n")
    
    print("--------------\n")
    print("|Score Matrix|\n")
    print("--------------\n")
    # 1st line of score matrix, sequence 1
    s = "\t\t"
    for c in seqs[0]:
        s += c + "\t"
    print(s + "\n")

    # 2nd line of score matrix, zeros
    s = "\t"
    for score in score_matrix[0]:
        s += str(score) + "\t"
    print(s + "\n")

    # the rest, one letter in sequence 2 + matrix row
    for i in range(m):
        s = seqs[1][i] + "\t"
        for score in score_matrix[i+1]:
            s += str(score) + "\t"
        print(s + "\n")
    
    print("----------------------\n")
    print("|Best Local Alignment|\n")
    print("----------------------\n")
    
    print("Alignment Score:" + str(a_score) + "\n")
    print("Alignment Results:\n")
    print(align0 + "\n")
    print(matches + "\n")
    print(align1)

### Run your Smith-Waterman Algorithm
runSW(args.input, args.score, args.opengap, args.extgap)
